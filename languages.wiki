<[autotemplate]
title={Practial Lessons from Exotic Languages}
[autotemplate]>

\def\cpp{{C\nolinebreak[4]\hspace{-.05em}\raisebox{.4ex}{\tiny \bf ++}}}
\def\cs{{C\nolinebreak\hspace{-.05em}\raisebox{.3ex}{\small \bf $\sharp$}}}


== Overview ==

==== Me ====

* Programmer
* Dozens of languages

==== Your Languages ====

* Java
* C
* \cpp
* \cs

==== My Languages ====

* Forth
* Haskell
* Prolog

==== Other Languages ====

* ECMAScripts (ActionScript, JavaScript)
* Lisps (CL, Scheme)
* PHP
* Python

==== Concepts ====

* Factoring
* Higher-level operations
* Declarative design

== Factoring ==

==== Concatenative Factoring ====

<[code][style=basic]
2 dup * dup * .
[code]>

<[code][style=basic]
: sq dup * ;
2 sq sq .
[code]>

==== Practical Factoring ====

<[code][style=basic,language=Python]
e = ('\x00' * (4 - len(e))) + e
n = ('\x00' * (4 - len(n))) + n
[code]>

<[code][style=basic,language=Python]
def f(x):
    return ('\x00' * (4 - len(x)) + x

e = f(e)
n = f(n)
[code]>

<[code][style=basic,language=Python]
def f(x):
    return x.rjust(4, '\x00')

e = f(e)
n = f(n)
[code]>

== Higher-level Operations ==

=== Theory ===

==== Linguistic Support ====

* Higher-order functions (C, \cpp, \cs)
* Sufficiently polymorphic types (Java, \cpp, \cs)

==== Common Operations ====

* Fold (catamorphic operator)
* Map
* Filter
* Zip (convolved map)
* Zip-with

=== Practice ===

==== In Functional Languages ====

* Haskell
** @foldr@
** @map@
** @filter@
** @zip@
** @zipWith@
* Python
** @reduce@
** @map@
** @filter@
** @zip@

==== In Imperative Languages ====

* \cpp
** Fold: @std::accumulate@
** Iteration: @std::for\_each@
** Map/zip-with: @std::transform@
** Filter: @std::remove@, @std::remove\_if@, @std::remove\_copy@, @std::remove\_copy\_if@
* \cs
** Fold: @IEnumerable<T>.Aggregate@
** Map: @IEnumerable<T>.Select@
** Filter: @IEnumerable<T>.Where@
** Zip-with: @IEnumerable<T>.Zip@

==== C Example ====

<[code][style=basic,language=C]
[code]>

== Declarative Design ==

=== Facts ===

==== Ad-hoc Constants ====

<[code][style=basic,language=Python]
AIR, STONE, GRASS, DIRT = range(4)
[code]>

* Freakin' constants, how do they work?

==== Classes of Facts ====

<[code][style=basic,language=Python]
class Block(object):

    def __init__(self, slot, name):
        self.slot = slot
        self.name = name

names = \["air", "stone", "grass", "dirt", ...\]

blocks = \[Block(slot, name)
           for slot, name in zip(xrange(256), names)\]

named_blocks = dict((block.name, block)
                    for block in blocks)
[code]>

* Note that ellipsis
* Maintainable? Maybe...
* 197 LoC for 90 objects

==== Databases, Done Dirt Cheap ====

<[code][style=basic,language=Python]
class Block(object):

    def __init__(self, slot, name, secondary=0):
        ...

class Item(object):

    def __init__(self, slot, name, secondary=0):
        ...
[code]>

* What's the difference, really?

==== Straight-up Reinvention of Wheels ====

<[code][style=basic,language=Python]
class Block(object):

    def __init__(self, slot, name, secondary=0,
                 drop=None, replace=0, ratio=1,
                 quantity=1, dim=16, breakable=True,
                 orientation=None):
        ...

# Torches are orientable and don't dim.
_add_block(Block(50, "torch",
           orientation=(None, 5, 4, 3, 2, 1), dim=0))
[code]>

* 793 LoC for 237 objects
* Ad-hoc queries
* Potato programming

==== Embedded DSLs ====

* Prolog
** SWI-Prolog
* Datalog
* SQL
** SQLite
*** Chrome/Chromium
*** Firefox/Thunderbird
*** Bundled in PHP and Python
*** Available in C/\cpp, Java, \cs
*** Native port in \cs

== Wrapping Up ==

==== Summary ====

* Exotic languages are awesome
* Imperative languages are practical
* Meet in the middle

==== Questions? ====

Special thanks to:

* People on @\#0x10c-dev@, @\#haskell@, @\#osu-lug@, and @\#python@ on Freenode
* Ben Kero and Spencer Krum
