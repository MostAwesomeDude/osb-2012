<[autotemplate]
title={Practial Lessons from Exotic Languages}
[autotemplate]>

\def\cpp{{C\nolinebreak[4]\hspace{-.05em}\raisebox{.4ex}{\tiny \bf ++}}}
\def\cs{{C\nolinebreak\hspace{-.05em}\raisebox{.3ex}{\small \bf $\sharp$}}}


== Overview ==

==== Your Languages ====

* Java
* C
* \cpp
* \cs

==== My Languages ====

* Forth
* Haskell
* Prolog

==== Concepts ====

* Factoring
* Higher-level operations
* Declarative design

== Factoring ==

==== Concatenative Factoring ====

<[code][style=basic]
2 dup * dup * .
[code]>

<[code][style=basic]
: sq dup * ;
2 sq sq .
[code]>

==== Practical Factoring ====

<[code][style=basic,language=Python]
e = ('\x00' * (4 - len(e))) + e
n = ('\x00' * (4 - len(n))) + n
[code]>

<[code][style=basic,language=Python]
def f(x):
    return ('\x00' * (4 - len(x)) + x

e = f(e)
n = f(n)
[code]>

<[code][style=basic,language=Python]
def f(x):
    return x.rjust(4, '\x00')

e = f(e)
n = f(n)
[code]>

== Higher-level Operations ==

=== Theory ===

==== Linguistic Support ====

* Higher-order functions (C, \cpp, \cs)
* Sufficiently polymorphic types (Java, \cpp, \cs)

==== Common Operations ====

* Fold (catamorphic operator)
* Map
* Filter
* Zip (convolved map)
* Zip-with

=== Practice ===

==== In Functional Languages ====

* Haskell
** @foldr@
** @map@
** @filter@
** @zip@
** @zipWith@
* Python
** @reduce@
** @map@
** @filter@
** @zip@

==== In Imperative Languages ====

* \cpp
** Fold: @std::accumulate@
** Iteration: @std::for\_each@
** Map/zip-with: @std::transform@
** Filter: @std::remove@, @std::remove\_if@, @std::remove\_copy@, @std::remove\_copy\_if@
* \cs
** Fold: @IEnumerable<T>.Aggregate@
** Map: @IEnumerable<T>.Select@
** Filter: @IEnumerable<T>.Where@
** Zip-with: @IEnumerable<T>.Zip@

==== C Example ====

<[code][style=basic,language=C]
[code]>

== Declarative Design ==

==== Embedded DSLs ====

* Prolog
** SWI-Prolog
* SQLite
** Chrome/Chromium
** Firefox/Thunderbird
** Bundled in PHP and Python
** Available in C/\cpp, Java, \cs
** Native port in \cs
